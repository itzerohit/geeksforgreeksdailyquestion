You are given an array arr[] of positive integers. Your task is to count the number of pairs (i, j) such that:


0 ≤ i < j ≤ n-1
gcd(arr[i], arr[j]) = 1
In other words, count the number of unordered pairs of indices (i, j) where the elements at those positions are co-prime.

Examples:

Input: arr[] = [1, 2, 3]
Output: 3
Explanation: (0,1), (0,2), (1,2) are the pair of indices where gcd(arr[i], arr[j]) = 1
Input: arr[] = [4, 8, 3, 9]
Output: 4
Explanation: (0,2), (0,3), (1,2), (1,3) are the pair of indices where gcd(arr[i], arr[j]) = 1
Constraints:
2 ≤ arr.size() ≤ 104
1 ≤ arr[i] ≤ 104

Expected Complexities
Topic Tags
Related Articles
If you are facing any issue on this page. Please let us know. \


solu -- 
import math
from collections import Counter

class Solution:
    def cntCoprime(self, arr):
        MAX = max(arr)
        n = len(arr)

        freq = [0] * (MAX + 1)
        for val in arr:
            freq[val] += 1

        # Count multiples
        cnt = [0] * (MAX + 1)
        for i in range(1, MAX + 1):
            for j in range(i, MAX + 1, i):
                cnt[i] += freq[j]

        # Precompute Möbius function
        mu = [1] * (MAX + 1)
        is_prime = [True] * (MAX + 1)
        for i in range(2, MAX + 1):
            if is_prime[i]:
                for j in range(i, MAX + 1, i):
                    is_prime[j] = False
                    mu[j] *= -1
                for j in range(i*i, MAX + 1, i*i):
                    mu[j] = 0

        # Count coprime pairs using Möbius
        res = 0
        for d in range(1, MAX + 1):
            if cnt[d] >= 2:
                res += mu[d] * (cnt[d] * (cnt[d] - 1)) // 2

        return res
